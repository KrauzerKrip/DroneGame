(()=>{"use strict";class t{constructor(t=0,e=0){this.x=t,this.y=e}add(e){return new t(this.x+e.x,this.y+e.y)}subtract(e){return new t(this.x-e.x,this.y-e.y)}scale(e){return new t(this.x*e,this.y*e)}dot(t){return this.x*t.x+this.y*t.y}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const e=this.magnitude();return 0===e?new t(0,0):this.scale(1/e)}perpendicular(){return new t(-this.y,this.x)}cross(t){return this.x*t.y-this.y*t.x}distanceTo(t){return Math.sqrt((this.x-t.x)*(this.x-t.x)+(this.y-t.y)*(this.y-t.y))}equals(t){return this.x===t.x&&this.y===t.y}toString(){return`Vec2(${this.x}, ${this.y})`}clone(){return new t(this.x,this.y)}}class e{constructor(e,i={position:new t(0,0),rotation:0,size:e.getSize()},s=function(){function t(){return Math.random().toString(16).slice(2,6)}return`${t()+t()}-${t()}-${(65536*Math.random()|16384).toString(16).slice(1)}-${(65536*Math.random()|32768).toString(16).slice(1)}-${t()+t()+t()}`}()){this.name=s,this.transform=i,this.sprite=e}onCollision(t){}update(t){}render(){const e=window.innerHeight-(this.transform.position.y+.5*this.sprite.getSize().y);this.sprite.setPosition(new t(this.transform.position.x,e)),this.sprite.setRotation(this.transform.rotation)}}class i{constructor(e,i){this.pos=new t(0,0),this.rot=0,this.element=e,this.imgElement=i}static fromImage(t){const e=document.createElement("div"),s=document.createElement("img");return s.src=t,s.onload=()=>{e.style.width=`${s.width}px`,e.style.height=`${s.height}px`},e.appendChild(s),e.style.position="absolute",document.body.appendChild(e),new i(e,s)}getSize(){return new t(this.imgElement.width,this.imgElement.height)}setPosition(t){this.pos=t,this.updateStyle()}getRotation(){return this.rot}setRotation(t){this.rot=t,this.updateStyle()}setSize(t){this.element.style.width=`${t.x}`,this.element.style.height=`${t.y}`,this.imgElement.width=t.x,this.imgElement.height=t.y}updateStyle(){this.element.style.transform=`\n      translate(${this.pos.x}px, ${this.pos.y}px)\n      rotate(${this.rot}deg)\n    `}}class s extends e{constructor(e,s){super(i.fromImage("resources/sprites/drone.png"),{position:e,rotation:s,size:new t(140,48)}),this.mass=1,this.momentOfInertia=.5,this.position=new t,this.velocity=new t,this.acceleration=new t,this.rotation=0,this.angularVelocity=0,this.angularAcceleration=0,this.engineForce=16,this.engineOffset=72,this.gravity=new t(0,-9.8),this.leftEngineActive=!1,this.rightEngineActive=!1,window.addEventListener("keydown",this.onKeyDown.bind(this)),window.addEventListener("keyup",this.onKeyUp.bind(this))}onKeyDown(t){"a"!==t.key&&"A"!==t.key||(this.leftEngineActive=!0),"d"!==t.key&&"D"!==t.key||(this.rightEngineActive=!0)}onKeyUp(t){"a"!==t.key&&"A"!==t.key||(this.leftEngineActive=!1),"d"!==t.key&&"D"!==t.key||(this.rightEngineActive=!1)}onCollision(t){alert("You have collided with an obstacle! Please, restart the training program.")}update(e){let i=this.gravity.clone(),s=0;if(this.leftEngineActive){const t=this.calculateEngineForce(!0);i=i.add(t),s+=this.calculateTorque(t,!0)}if(this.rightEngineActive){const t=this.calculateEngineForce(!1);i=i.add(t),s+=this.calculateTorque(t,!1)}s*=.05,i=new t(300*i.x,10*i.y),this.applyForce(i,e),this.applyTorque(s,e),this.updateKinematics(e),this.applyDamping(e),super.update(e)}calculateEngineForce(e){const i=new t(0,this.engineForce);return this.rotateVector(i,this.rotation)}calculateTorque(t,e){const i=e?-1:1;return t.magnitude()*i*5}applyTorque(t,e){const i=Math.PI;this.angularAcceleration=t/this.momentOfInertia,this.angularVelocity+=this.angularAcceleration*e,this.angularVelocity=Math.max(-i,Math.min(i,this.angularVelocity))}applyForce(e,i){this.acceleration=e.scale(1/this.mass),this.velocity=this.velocity.add(this.acceleration.scale(i)),this.velocity=new t(-this.velocity.x,this.velocity.y)}updateKinematics(t){this.transform.position=this.transform.position.add(this.velocity.scale(t)),this.rotation+=this.angularVelocity*t,this.transform.rotation=this.rotation*(180/Math.PI)}applyDamping(t){this.velocity=this.velocity.scale(.99),this.angularVelocity*=.99}rotateVector(e,i){const s=Math.cos(i),n=Math.sin(i);return new t(e.x*s-e.y*n,e.x*n+e.y*s)}}class n extends e{constructor(t,e,s){const n=i.fromImage("resources/sprites/obstacle.png");n.setSize(s),super(n,{position:t,rotation:e,size:s})}}class o{constructor(e,i,s=0){this.center=e,this.halfSize=new t(.5*i.x,.5*i.y),this.rotation=s*(Math.PI/180)}rotatePoint(e,i){const s=Math.cos(i),n=Math.sin(i);return new t(e.x*s-e.y*n,e.x*n+e.y*s)}getCorners(){return[new t(-this.halfSize.x,-this.halfSize.y),new t(this.halfSize.x,-this.halfSize.y),new t(this.halfSize.x,this.halfSize.y),new t(-this.halfSize.x,this.halfSize.y)].map((e=>{const i=this.rotatePoint(e,this.rotation);return new t(i.x+this.center.x,i.y+this.center.y)}))}getAxes(){return[this.rotatePoint(new t(1,0),this.rotation),this.rotatePoint(new t(0,1),this.rotation)]}projectPoints(t,e){const i=t.map((t=>t.x*e.x+t.y*e.y));return{min:Math.min(...i),max:Math.max(...i)}}intersects(t){const e=[...this.getAxes(),...t.getAxes()];for(const i of e){const e=this.projectPoints(this.getCorners(),i),s=this.projectPoints(t.getCorners(),i);if(e.max<s.min||s.max<e.min)return!1}return!0}containsPoint(e){const i=this.rotatePoint(new t(e.x-this.center.x,e.y-this.center.y),-this.rotation);return Math.abs(i.x)<=this.halfSize.x&&Math.abs(i.y)<=this.halfSize.y}move(e){return new o(new t(this.center.x+e.x,this.center.y+e.y),new t(2*this.halfSize.x,2*this.halfSize.y),this.rotation*(180/Math.PI))}rotate(e){return new o(this.center,new t(2*this.halfSize.x,2*this.halfSize.y),(this.rotation+e)*(180/Math.PI))}}const r=new class{constructor(){this.gameObjects={},this.lastRenderTime=Date.now()}create(){const e=new s(new t(.25*window.innerWidth+100,.5*window.innerHeight),0),i=new n(new t(200,400),0,new t(1080,50)),o=new n(new t(200,300),0,new t(400,500)),r=new n(new t(0,1100),0,new t(400,100)),a=new n(new t(400,1100),0,new t(900,100)),h=new n(new t(-500,500),0,new t(100,1e3));this.gameObjects[e.name]=e,this.gameObjects[i.name]=i,this.gameObjects[o.name]=o,this.gameObjects[r.name]=r,this.gameObjects[a.name]=a,this.gameObjects[h.name]=h}runGameLoop(){this.gameLoop()}handleCollisions(){for(const t in this.gameObjects){const e=this.gameObjects[t],i=new o(e.transform.position,e.transform.size,e.transform.rotation);for(const t in this.gameObjects){const s=this.gameObjects[t];if(e===s)continue;const n=new o(s.transform.position,s.transform.size,s.transform.rotation);i.intersects(n)&&(e.onCollision(s),s.onCollision(e))}}}gameLoop(){const t=Date.now()-this.lastRenderTime;this.handleCollisions();for(const e in this.gameObjects)this.gameObjects[e].update(t/1e3);for(const t in this.gameObjects)this.gameObjects[t].render();this.lastRenderTime=Date.now(),requestAnimationFrame((()=>this.gameLoop()))}};r.create(),r.runGameLoop()})();